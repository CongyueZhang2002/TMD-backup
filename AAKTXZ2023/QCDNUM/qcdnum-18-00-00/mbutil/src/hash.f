
C--   This is the file hash.f with Pearson hash routines
C--
C--   The routines below hash a message which is an array of numbers:
C--
C--        integer array          --> imb_ihash
C--        integers in dp format  --> imb_jhash
C--        double precision array --> imb_dhash
C--
C--   The Pearson hash function handles byte-integers (integers in the
C--   range 0-255) so that input is first converted into byte streams:
C--
C--       integer   --> 4 bytes
C--       dp number --> integer mantissa and exponent --> 8 bytes
C--
C--   The output hash is a 4-byte integer with the bytes generated by
C--   hashing a message 4 times with 4 different input seeds, taken to
C--   be just the byte number [1-4].
c--
C--   The Pearson hash function is taken from wikipedia.org
C--
C--   imb_ihash(iseed,imsg,n)       Hash integer message
C--   imb_jhash(iseed,dmsg,n)       Hash integers in dp format
C--   imb_dhash(iseed,dmsg,n)       Hash dp floating-point message
C--
C--   smbMultHash(ib,n,ih,m)        Multiple hashes with different seeds
C--   imbHashBmsg(iseed,ib,n)       Hash an array of byte-integers
C--   imbFPearson(iseed,ibyte)      Pearson hash function
C--   imbRandByte(ibyte)            Return pseudo-random byte-integer
C--
C--   smbIbytes(ii,ib)              Extract the 4 bytes of an integer
C--   smbDbytes(dd,ib)              Extract the 8 bytes of a dp number
C--   smbMantEx(dd,nn,im,ie)        Mantissa and exponent of a dp number

C==   ==================================================================
C==   User interface routines ==========================================
C==   ==================================================================

C-----------------------------------------------------------------------
CXXHDR
CXXHDR    /************************************************************/
CXXHDR    /*  MBUTIL hash routines from hash.f                        */
CXXHDR    /************************************************************/
CXXHDR
C-----------------------------------------------------------------------
CXXHFW
CXXHFW  /**************************************************************/
CXXHFW  /*  MBUTIL hash routines from hash.f                          */
CXXHFW  /**************************************************************/
CXXHFW
C-----------------------------------------------------------------------
CXXWRP
CXXWRP  /**************************************************************/
CXXWRP  /*  MBUTIL hash routines from hash.f                          */
CXXWRP  /**************************************************************/
CXXWRP
C-----------------------------------------------------------------------

C-----------------------------------------------------------------------
CXXHDR    int imb_ihash(int iseed, int *imsg, int n);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_ihash FC_FUNC(imb_ihash,IMB_IHASH)
CXXHFW    int fimb_ihash(int*, int*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_ihash(int iseed, int *imsg, int n)
CXXWRP    {
CXXWRP      return fimb_ihash(&iseed, imsg, &n);
CXXWRP    }
C-----------------------------------------------------------------------

C     ========================================
      integer function imb_ihash(iseed,imsg,n)
C     ========================================

C--   Return a 4-byte hash of an integer message
C--
C--   iseed      (in) : integer seed == 0 --> generate seed
C--                                  != 0 --> use as a seed
C--   imsg(n)    (in) : integer array
C--   n          (in) : size of imsg
C--   imb_ihash (out) : 4-byte hash
C--
C--   Author: Michiel Botje h24@nikhef.nl   22-10-19

      implicit double precision (a-h,o-z)

      dimension imsg(*), ib(4), ih(4)

C--   Initial seed
      if(iseed.eq.0) then
        ih(1) = 1
        ih(2) = 2
        ih(3) = 3
        ih(4) = 4
      else
        call smbIbytes(iseed,ih)
      endif

C--   Loop over the message
      do i = 1,n
C--     Extract bytes
        call smbIbytes(imsg(i),ib)
C--     Hash
        call smbMultHash(ib,4,ih,4)
      enddo

C--   Set bytes in output hash
      call smb_cbyte(ih(1),1,ihash,1)    !set byte 1
      call smb_cbyte(ih(2),1,ihash,2)    !set byte 2
      call smb_cbyte(ih(3),1,ihash,3)    !set byte 3
      call smb_cbyte(ih(4),1,ihash,4)    !set byte 4

C--   Done
      imb_ihash = ihash

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_jhash(int iseed, double *dmsg, int n);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_jhash FC_FUNC(imb_jhash,IMB_JHASH)
CXXHFW    int fimb_jhash(int*, double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_jhash(int iseed, double *dmsg, int n)
CXXWRP    {
CXXWRP      return fimb_jhash(&iseed, dmsg, &n);
CXXWRP    }
C-----------------------------------------------------------------------

C     ========================================
      integer function imb_jhash(iseed,dmsg,n)
C     ========================================

C--   Return a 4-byte hash of integers stored as dp numbers
C--
C--   iseed      (in) : integer seed == 0 --> generate seed
C--                                  != 0 --> use as a seed
C--   dmsg(n)    (in) : double precision array with integer numbers
C--   n          (in) : size of dmsg
C--   imb_jhash (out) : 4-byte hash
C--
C--   Author: Michiel Botje h24@nikhef.nl   22-10-19

      implicit double precision (a-h,o-z)

      dimension dmsg(*), ib(4), ih(4)

C--   Initial seed
      if(iseed.eq.0) then
        ih(1) = 1
        ih(2) = 2
        ih(3) = 3
        ih(4) = 4
      else
        call smbIbytes(iseed,ih)
      endif

C--   Loop over the message
      do i = 1,n
C--     Extract bytes
        call smbIbytes(int(dmsg(i)),ib)
C--     Hash
        call smbMultHash(ib,4,ih,4)
      enddo

C--   Set bytes in output hash
      call smb_cbyte(ih(1),1,ihash,1)    !set byte 1
      call smb_cbyte(ih(2),1,ihash,2)    !set byte 2
      call smb_cbyte(ih(3),1,ihash,3)    !set byte 3
      call smb_cbyte(ih(4),1,ihash,4)    !set byte 4

C--   Done
      imb_jhash = ihash

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_dhash(int iseed, double *dmsg, int n);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_dhash FC_FUNC(imb_dhash,IMB_DHASH)
CXXHFW    int fimb_dhash(int*, double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_dhash(int iseed, double *dmsg, int n)
CXXWRP    {
CXXWRP      return fimb_dhash(&iseed, dmsg, &n);
CXXWRP    }
C-----------------------------------------------------------------------

C     ========================================
      integer function imb_dhash(iseed,dmsg,n)
C     ========================================

C--   Return a 4-byte hash of a dp floating-point message
C--   The dp numbers are rounded to 9-digit precision before the hash
C--
C--   iseed      (in) : integer seed == 0 --> generate seed
C--                                  != 0 --> use as a seed
C--   dmsg(n)    (in) : double precision array
C--   n          (in) : size of dmsg
C--   imb_dhash (out) : 4-byte hash
C--
C--   Author: Michiel Botje h24@nikhef.nl   22-10-19

      implicit double precision (a-h,o-z)

      dimension dmsg(*), ib(8), ih(4)

C--   Initial seed
      if(iseed.eq.0) then
        ih(1) = 1
        ih(2) = 2
        ih(3) = 3
        ih(4) = 4
      else
        call smbIbytes(iseed,ih)
      endif

C--   Loop over the message
      do i = 1,n
C--     Extract bytes (with mantissa rounded to 9 digits)
        call smbDbytes(dmsg(i),ib)
C--     Hash
        call smbMultHash(ib,8,ih,4)
      enddo

C--   Set bytes in output hash
      call smb_cbyte(ih(1),1,ihash,1)    !set byte 1
      call smb_cbyte(ih(2),1,ihash,2)    !set byte 2
      call smb_cbyte(ih(3),1,ihash,3)    !set byte 3
      call smb_cbyte(ih(4),1,ihash,4)    !set byte 4

C--   Done
      imb_dhash = ihash

      return
      end


C==   ==================================================================
C==   Basic hash routines ==============================================
C==   ==================================================================

C     =================================
      subroutine smbMultHash(ib,n,ih,m)
C     =================================

C--   Multiple hashes of an n-byte message with different seeds
C--
C--   ib(n)      (in) : array of byte-integers (message)
C--   n          (in) : size of message
C--   ih(m)   (inout) : array of byte-integer seeds on input and filled
C--                     with the hashes on exit
C--   m          (in) : number of hash-runs on ib
C--
C--   Author: Michiel Botje h24@nikhef.nl   22-10-19

      implicit double precision (a-h,o-z)

      dimension ib(*), ih(*)

C--   Do m hash runs on ib
      do i = 1,m
        ih(i) = imbHashBmsg(ih(i),ib,n)
      enddo

      return
      end

C     ========================================
      integer function imbHashBmsg(iseed,ib,n)
C     ========================================

C--   Return 1-byte hash of a message of n byte-integers
C--
C--   iseed        (in) : integer in the range [0,255]
C--   ib(n)        (in) : array of integers in the range [0,255]
C--   imbHashBmsg (out) : hash in the range [0,255]
C--
C--   Author: Michiel Botje h24@nikhef.nl   21-10-19

      implicit double precision (a-h,o-z)

      dimension ib(*)

      imbHashBmsg = 0
      ih          = iseed
      do i = 1,n
        ih = imbFPearson(ih,ib(i))
      enddo
      imbHashBmsg = ih

      return
      end

C     =========================================
      integer function imbFPearson(iseed,ibyte)
C     =========================================

C--   Pearson hash function.
C--   Returns a pseudo-random byte as a funtion of iseed and ibyte
C--
C--   iseed        (in) : integer in the range [0,255]
C--   ibyte        (in) : integer in the range [0,255]
C--   imbFPearson (out) : integer in the range [0,255]
C--
C--   Author: Michiel Botje h24@nikhef.nl   21-10-19

      implicit double precision (a-h,o-z)

      imbFPearson = imbRandByte(ieor(iseed,ibyte))

      return
      end

C     ===================================
      integer function imbRandByte(ibyte)
C     ===================================

C--   Returns a pseudo-random byte-integer
C--
C--   ibyte        (in) : integer in the range  [0,255]
C--   imbRandByte (out) : pseudo-random integer [0,255]
C--
C--   Author: Michiel Botje h24@nikhef.nl   21-10-19

      implicit double precision (a-h,o-z)

      dimension isaMess(0:255)
      data      isaMess /
     +  98,  6, 85,150, 36, 23,112,164,135,207,169,  5, 26, 64,165,219,
     +  61, 20, 68, 89,130, 63, 52,102, 24,229,132,245, 80,216,195,115,
     +  90,168,156,203,177,120,  2,190,188,  7,100,185,174,243,162, 10,
     + 237, 18,253,225,  8,208,172,244,255,126,101, 79,145,235,228,121,
     + 123,251, 67,250,161,  0,107, 97,241,111,181, 82,249, 33, 69, 55,
     +  59,153, 29,  9,213,167, 84, 93, 30, 46, 94, 75,151,114, 73,222,
     + 197, 96,210, 45, 16,227,248,202, 51,152,252,125, 81,206,215,186,
     +  39,158,178,187,131,136,  1, 49, 50, 17,141, 91, 47,129, 60, 99,
     + 154, 35, 86,171,105, 34, 38,200,147, 58, 77,118,173,246, 76,254,
     + 133,232,196,144,198,124, 53,  4,108, 74,223,234,134,230,157,139,
     + 189,205,199,128,176, 19,211,236,127,192,231, 70,233, 88,146, 44,
     + 183,201, 22, 83, 13,214,116,109,159, 32, 95,226,140,220, 57, 12,
     + 221, 31,209,182,143, 92,149,184,148, 62,113, 65, 37, 27,106,166,
     +   3, 14,204, 72, 21, 41, 56, 66, 28,193, 40,217, 25, 54,179,117,
     + 238, 87,240,155,180,170,242,212,191,163, 78,218,137,194,175,110,
     +  43,119,224, 71,122,142, 42,160,104, 48,247,103, 15, 11,138,239 /

      imbRandByte = isaMess(ibyte)

      return
      end

C==   ==================================================================
C==   Convert numbers into byte streams ================================
C==   ==================================================================

C     ===========================
      subroutine smbIbytes(ii,ib)
C     ===========================

C--   Get the 4 bytes of integer ii
C--
C--   ii     (in) : 4-byte integer
C--   ib(4) (out) : four bytes of i
C--
C--   Author: Michiel Botje    m.botje@nikhef.nl    24-09-2019

      implicit double precision (a-h,o-z)

      dimension ib(*)

      do j = 1,4
        ib(j) = 0
        call smb_cbyte(ii,j,ib(j),1)
      enddo

      return
      end

C     ===========================
      subroutine smbDbytes(dd,ib)
C     ===========================

C--   Get the 8 bytes of double precision number dd, that is,
C--   4 bytes of the mantissa and 4 bytes of the exponent
C--   The mantissa is rounded to 9 significant digits
C--
C--   dd     (in) : double precision number
C--   ib(8) (out) : eight bytes of dd (mantissa + exponent)
C--
C--   Author: Michiel Botje    m.botje@nikhef.nl    24-09-2019

      implicit double precision (a-h,o-z)

      dimension ib(*)

      call smbMantEx(dd,9,im,ie)
      call smbIbytes(im,ib(1))
      call smbIbytes(ie,ib(5))

      return
      end

C     =================================
      subroutine smbMantEx(dd,nn,im,ie)
C     =================================

C--   Decompose a floating point number into mantissa and exponent
C--
C--   dd   (in) : double precision number
C--   nn   (in) : significant digits to keep
C--   im  (out) : mantissa rounded to 9 digits
C--   ie  (out) : exponent (has at most 3 digits)
C--
C--   Author: Michiel Botje    m.botje@nikhef.nl    24-09-2019

      implicit double precision (a-h,o-z)

      character*25 number
      character*9 fmt

      mm = max(nn,1)
      mm = min(mm,9)
      write(fmt,'(''(E20.'',I1,''E3)'')') mm
      write(number,fmt) dd
      idot = index(number,'.')
      ieee = index(number,'E')
      read(number(idot+1:ieee-1),'(I9)') im
      if(number(idot-2:idot-2).eq.'-')   im = -im
      read(number(ieee+1:ieee+4),'(I4)') ie

      return
      end
