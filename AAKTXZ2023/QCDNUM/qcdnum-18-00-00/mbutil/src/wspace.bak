
C--  This is the file wspace.f with workspace routines
C--  This file also contains C++ wrappers for all the Fortran routines
C--
c--   imb_WsInitCPP(w,nw,nt,txt,ls)       Wrapper for WsInit
C--   imb_WsInit(w,nw,nt,txt)             Create workspace
C--   smbWsEbuf(w,txt,opt)                Handle message text buffer
C--   smbWsEmsg(w,n,srname)               Out-of-space error message
C--   smb_SetWsn(w,nw)                    Update workspace size info
C--   imb_NewSet(w)                       Create new table-set
C--   integer function imbEtrailer(w)     Yes/no w has empty trailer set
C--   imb_WTable(w,imi,ima,n)             Create new table
C--   imb_WClone(w1,ia1,w2)               Clone a table-set or table
C--   imbTClone(w1,ia1,w2)                Clone a table
C--   smb_TbCopy(w1,ia1,w2,ia2,itag)      Copy table contents
C--   smb_WsWipe(w,ia)                    Wipe workspace
C--   smb_TsDump(fname,key,w,ia,ierr)     Dump table-set to disk
C--   imb_TsRead(fname,key,w,ierr)        Append table set from disk
C--   smb_WsMark(mws,mset,mtab)           Get markers
C--   imb_HdSize()                        Header size
C--   imb_TbSize(imi,ima,ndim)            Table size

C--   smbGetMeta(w,ia,nd,kk,imi,ima)      Extract metadata
C--   imb_TPoint(w,iw,index,n)            Pointer function

C--   imb_IsaWorkspace(w)                 True if w is a workspace
C--   imb_SizeOfW(w)                      Total size of w
C--   imb_WordsUsed(w)                    Words used
C--   imb_Nheader(w)                      Header size
C--   imb_Ntags(w)                        Tag field size
C--   imb_HeadSkip(w)                     Header + tag field size
C--   imb_IaRoot()                        Root address
C--   imb_IaDrain(w)                      Drain-word address
C--   imb_IaNull(w)                       Null-word address
C--   imb_ObjectType(w,ia)                Object type
C--   imb_ObjectSize(w,ia)                Object size
C--   imb_Nobjects(w,ia)                  Number of objects
C--   imb_ObjectNumber(w,ia)              Objects number
C--   imb_FingerPrint(w,ia)               Fingerprint
C--   imb_IaFirstTag(w,ia)                Tagfield address
C--   imb_TableDim(w,ia)                  Number of table dimensions
C--   imb_IaKARRAY(w,ia)                  KARRAY first word
C--   imb_IaIMIN(w,ia)                    IMIN first word
C--   imb_IaIMAX(w,ia)                    IMAX first word
C--   imb_BeginTbody(w,ia)                Begin table body
C--   imb_EndTbody(w,ia)                  End table body

C--   imb_TFskip(w,ia)                    Forward skip table
C--   imb_TBskip(w,ia)                    Reverse skip table
C--   imb_SFskip(w,ia)                    Forward skip tset
C--   imb_SBskip(w,ia)                    Reverse skip tset

C--   smb_WStree(w)                       Dump workspace tree
C--   smb_WShead(w,ia)                    Dump object header


C--   Block of words: frst, last, next, size
C--
C--   size  =  last - frst + 1  =  next - frst   -->   size >= 1
C--   next  =  frst + size      =  last + 1
C--   last  =  frst + size - 1  =  next - 1
C--   frst  =  last - size + 1  =  next - size

C23456789012345678901234567890123456789012345678901234567890123456789012
C-----------------------------------------------------------------------
CXXHDR
CXXHDR    /************************************************************/
CXXHDR    /*  MBUTIL workspace routines from wspace.f                 */
CXXHDR    /************************************************************/
CXXHDR
CXXHDR    inline int iaFtoC(int ia) { return ia-1; };
CXXHDR    inline int iaCtoF(int ia) { return ia+1; };
CXXHDR
C-----------------------------------------------------------------------
CXXHFW
CXXHFW  /**************************************************************/
CXXHFW  /*  MBUTIL workspace routines from wspace.f                   */
CXXHFW  /**************************************************************/
CXXHFW
C-----------------------------------------------------------------------
CXXWRP
CXXWRP  /**************************************************************/
CXXWRP  /*  MBUTIL workspace routines from wspace.f                   */
CXXWRP  /**************************************************************/
CXXWRP
C-----------------------------------------------------------------------

C-----------------------------------------------------------------------
CXXHDR    int imb_wsinit(double *w, int nw, int nt, string txt);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_wsinitcpp FC_FUNC(imb_wsinitcpp,IMB_WSINITCPP)
CXXHFW    int fimb_wsinitcpp(double*, int*, int*, char*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_wsinit(double *w, int nw, int nt, string txt)
CXXWRP    {
CXXWRP      int ls = txt.size();
CXXWRP      char *ctxt = new char[ls];
CXXWRP      strcpy(ctxt,txt.c_str());
CXXWRP      int ia = fimb_wsinitcpp(w, &nw, &nt, ctxt, &ls);
CXXWRP      delete[] ctxt;
CXXWRP      return iaFtoC(ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     ==============================================
      integer function imb_WsInitCPP(w,nw,nt,txt,ls)
C     ==============================================

      implicit double precision (a-h,o-z)

      dimension w(*)
      character*(100) txt

      if(ls.gt.100) stop
     +             'MBUTIL::IMB_WSINIT: input text > 100 characters'

      imb_WsInitCpp = imb_WsInit(w,nw,nt,txt(1:ls))

      return
      end

C     ========================================
      integer function imb_WsInit(w,nw,nt,txt)
C     ========================================

C--   Create new workspace with first (empty) table-set
C--
C--   w           (in): double precision array w(nw)
C--   nw          (in): dimension of w declared in calling routine
C--   nt          (in): requested tag field size
C--   txt         (in): comment line when w runs out of space
C--   imb_WsInit (out): IA address of the first table-set

C--   Author: Michiel Botje h24@nikhef.nl   17-11-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      character*(*) txt
      character*10  date, time, zone
      dimension     ival(8)
      character*20  ntxt

      save icnt
      data icnt /0/

C--   Check input
      if(nw.le.0) stop
     + 'MBUTIL:IMB_WSINIT: cannot have workspace size NW <= 0'
      if(nt.lt.0) stop
     + 'MBUTIL:IMB_WSINIT: cannot have tag field size NT < 0'
C--   Check size (for wspace and first table set)
      nhskip = nwHeader0 + nt
      nsize  = nhskip + nhskip
      nneed  = nsize + 1
      if(nw.lt.nneed) then
        call smb_itoch(nneed,ntxt,leng)
        write(6,*)
     + 'MBUTIL:IMB_WSINIT: workspace size must be at least ',
     +  ntxt(1:leng),' words'
        if(imb_lastc(txt).ne.0) write(6,*) txt
        stop
      endif
C--   Workspace fingerprint
      call date_and_time(date,time,zone,ival)      !millisec resolution
      icnt  = icnt+1                               !count calls
      iseed = 0                                    !call-dependent seed
      do i = 1,4
        call smb_cbyte(mod(icnt+i,256),1,iseed,i)  !set 4 bytes of iseed
      enddo
      ihash = imb_ihash(iseed,ival,8)              !hash year-date-time
C--   Initialise store
      call smb_Vfill(w,nw,0.D0)
C--   Workspace header
      w(ICword0+iroot0) = dble(iWsVersion0)     !Control word
      w(IwAddr0+iroot0) = 0.D0                  !IW address
      w(NFTabl0+iroot0) = 0.D0                  !Fskip table
      w(NBTabl0+iroot0) = 0.D0                  !Bskip table
      w(NFTset0+iroot0) = dble(nhskip)          !Fskip tset
      w(NBTset0+iroot0) = 0.D0                  !Bskip tset
      w(Ifprnt0+iroot0) = dble(ihash)           !Fingerprint
      w(NObjec0+iroot0) = 1.D0                  !Number of objects
      w(IObjec0+iroot0) = 1.D0                  !Object number
      w(IWlstS0+iroot0) = dble(nhskip)          !IW last table-set in w
      w(IWlstT0+iroot0) = dble(nhskip+nhskip)   !IW last table in w
      w(INwMax0+iroot0) = dble(nw)              !Wspace total size
      w(INwUse0+iroot0) = dble(nsize)           !Words used
      w(IDrain0+iroot0) = 0.D0                  !Drain word
      w(iZnull0+iroot0) = 1.D20                 !Null word
C--   Initial table-set fingerprint
      ival(1) = nwHeader0
      ival(2) = nt
      ihash   = 0
      ihash   = imb_ihash(ihash,ival,2)
C--   First table-set address
      iaS     = nhskip + iroot0
C--   Fill Header first table set
      w(ICword0+iaS) = dble(iCWTableSet0)       !control word
      w(IwAddr0+iaS) = dble(nhskip)             !IW
      w(NFTabl0+iaS) = 0.D0                     !Fskip table
      w(NBTabl0+iaS) = 0.D0                     !Bskip table
      w(NFTset0+iaS) = 0.D0                     !Fskip tset
      w(NBTset0+iaS) = 0.D0                     !Bskip tset
      w(Ifprnt0+iaS) = dble(ihash)              !fingerprint
      w(NObjec0+iaS) = 0.D0                     !number of tables
      w(IObjec0+iaS) = 1.D0                     !Object number
      w(INwUse0+iaS) = dble(nhskip)             !Oject  size
      w(INhead0+iaS) = dble(nwHeader0)          !Header size
      w(INtags0+iaS) = dble(nt)                 !Tag size
      w(IHskip0+iaS) = dble(nhskip)             !Hskip
      w(ISlstT0+iaS) = dble(nhskip)             !IS first table in ts
C--   Store message
      call smbWsEbuf(w,txt,'in')
C--   Return address first table-set
      imb_WsInit = iaS

      return
      end

C     ===============================
      subroutine smbWsEbuf(w,txt,opt)
C     ===============================

C--   Store (opt = 'in') or retrieve (opt = 'out') message text

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)
      character*(*) txt, opt

      save ebuf, ifp, nebuf, first
      character*80 ebuf(mebuf0)
      dimension ifp(mebuf0)
      logical first
      data first/.true./

C--   Initialise
      if(first) then
        nebuf = 0
        do i = 1,mebuf0
          call smb_cfill(' ',ebuf(i))
          ifp(i) = 0
        enddo
        first = .false.
      endif

C--   Workspace fingerprint
      ifpw = int(w(IFprnt0+iroot0))
C--   Find workspace entry
      iws  = 0
      do i = 1,nebuf
        if(ifp(i).eq.ifpw) iws = i
      enddo
      if(opt(1:1).eq.'i' .or. opt(1:1).eq.'I') then
C--     Store new message
C--     Empty message
        if(imb_lastc(txt).eq.0) return
        if(iws.ne.0) then
C--       Overwrite
          ebuf(iws) = txt
        else
C--       New entry
          nebuf = nebuf+1
          if(nebuf.gt.mebuf0) then
            write(6,*) 'MBUTIL:IMB_WSINIT: message buffer size exceeded'
            write(6,*)
     +                'Please increase MEBUF0 in mbutil/inc/wspace0.inc'
            stop
          endif
          ebuf(nebuf) = txt
          ifp(nebuf)  = ifpw
        endif
      elseif(opt(1:1).eq.'o' .or. opt(1:1).eq.'O') then
C--     Retrieve message
        if(iws.eq.0) then
C--       Workspace not found
          call smb_cfill(' ',txt)
        else
          txt = ebuf(iws)
        endif
      else
        stop 'MBUTIL:smbWsEbuf: unknown option'
      endif

      return

      end

C     ================================
      subroutine smbWsEmsg(w,n,srname)
C     ================================

C--   Out-of-space message

      implicit double precision(a-h,o-z)

      dimension w(*)
      character*(*) srname
      character*20  ntxt
      character*80  txt

      i1 = imb_frstc(srname)
      i2 = imb_lastc(srname)
      call smb_itoch(n,ntxt,leng)
      call smbWsEbuf(w,txt,'out')
      write(6,*) srname(i1:i2),': workspace size must be at least ',
     +  ntxt(1:leng),' words'
      if(imb_lastc(txt).ne.0) write(6,*) txt
      stop

      end

C-----------------------------------------------------------------------
CXXHDR    void smb_setwsn(double *w, int nw);
C-----------------------------------------------------------------------
CXXHFW  #define fsmb_setwsn FC_FUNC(smb_setwsn,SMB_SETWSN)
CXXHFW    void fsmb_setwsn(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    void smb_setwsn(double *w, int nw)
CXXWRP    {
CXXWRP     fsmb_setwsn(w, &nw);
CXXWRP    }
C-----------------------------------------------------------------------

C     ===========================
      subroutine smb_SetWsn(w,nw)
C     ===========================

C--   Update size information in the workspace header
C--
C--   w               (in): workspace
C--   nw              (in): actual workspace size

C--   Author: Michiel Botje h24@nikhef.nl   25-02-20

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

C--   Check if workspace
      if(int(w(iCword0+iroot0)).ne.iWsVersion0) then
        stop 'MBUTIL:SMB_SETWSN: W is not a workspace'
      endif
C--   Check input
      nwold = int(w(INwMax0+iroot0))
      if(nw.lt.nwold) stop
     +    'MBUTIL:SMB_SETWSN: cannot decrease workspace size'
C--   Update header
      w(INwMax0+iroot0) = dble(nw)              !Wspace total size

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_newset(double *w);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_newset FC_FUNC(imb_newset,IMB_NEWSET)
CXXHFW    int fimb_newset(double*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_newset(double *w)
CXXWRP    {
CXXWRP     int ia = fimb_newset(w);
CXXWRP     return iaFtoC(ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     ==============================
      integer function imb_NewSet(w)
C     ==============================

C--   Book new table-set (if current one not empty)
C--
C--   w               (in): workspace
C--   imb_NewSet     (out): IA address of new table-set

C--   Author: Michiel Botje h24@nikhef.nl   17-11-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*), ival(2)

C--   Check if workspace
      if(int(w(iCword0+iroot0)).ne.iWsVersion0) then
        stop 'MBUTIL:IMB_NEWSET: W is not a workspace'
      endif
C--   Get info
      iaR    = iroot0                             !root address
      iaL    = int(w(IWlstS0+iaR)) + iaR          !IA current table-set
      iaS    = int(w(INwUse0+iaR)) + iaR          !IA new     table-set
      iaT    = int(w(IWlstT0+iaR)) + iaR          !IA last table
      NBskip = iaL-iaS                            !Bskip tset
      NTskip = iaT-iaS                            !Bskip table
      NObjec = int(w(NObjec0+iaR))                !# table-sets in w
C--   Do nothing if current set is empty
      if( imbEtrailer(w) .eq.1 ) then
        imb_NewSet = iaL
        return
      endif
C--   Check workspace size
      NHskip = int(w(IHskip0+iaL))                !header+tag size
      NWused = int(w(INwUse0+iaR))                !words used
      NWneed = NWused + NHskip + 1                !words needed
      Nspace = int(w(INwMax0+iaR))                !total size
C--   Run out-of-space
      if(NWneed.gt.Nspace) call smbWsEmsg(w,NWneed,'MBUTIL:IMB_NEWSET')
C--   Initial fingerprint
      Nhead   = int(w(INhead0+iaL))
      Ntags   = int(w(INtags0+iaL))
      ival(1) = Nhead
      ival(2) = Ntags
      ihash   = 0
      ihash   = imb_ihash(ihash,ival,2)
      NObjec  = NObjec + 1                        !update #table sets
C--   Fill Header
      w(ICword0+iaS) = dble(iCWTableSet0)         !control word
      w(IwAddr0+iaS) = dble(NWused)               !IW
      w(NFTabl0+iaS) = 0.D0                       !Fskip table
      w(NBTabl0+iaS) = dble(NTskip)               !Bskip table
      w(NFTset0+iaS) = 0.D0                       !Fskip tset
      w(NBTset0+iaS) = dble(NBskip)               !Bskip tset
      w(Ifprnt0+iaS) = dble(ihash)                !fingerprint
      w(NObjec0+iaS) = 0.D0                       !number of tables
      w(IObjec0+iaS) = dble(NObjec)               !Object number
      w(INwUse0+iaS) = dble(NHskip)               !Oject  size
      w(INhead0+iaS) = dble(Nhead)                !Header size
      w(INtags0+iaS) = dble(Ntags)                !Tag size
      w(IHskip0+iaS) = dble(NHskip)               !Hskip
      w(ISlstT0+iaS) = dble(NHskip)               !IS first table in ts
C--   Update Wspace Header
      w(NObjec0+iaR) = dble(NObjec)               !Number of objects
      w(IWlstS0+iaR) = dble(NWused)               !IW this table set
      w(IWlstT0+IaR) = dble(NWused+NHskip)        !IW first table in ts
      w(INwUse0+iaR) = dble(NWused+NHskip)        !Words used
C--   Return address
      imb_NewSet = iaS
C--   Done for first set
      if(NBskip.eq.0) return
C--   Update Header previous set
      w(NFTset0+iaL) = dble(iaS - iaL)            !SFskip tset
C--   Update Header previous tables
      nTab  = int(w(iaL+NObjec0))
      iaTab = int(w(iaL+NFTabl0)) + iaL
      do i = 1,nTab
        w(NFTset0+iaTab) = dble(iaS - iaTab)      !SFskip table in tset
        iaTab = int(w(iaTab+NFTabl0)) + iaTab
      enddo

      return
      end

C     ===============================
      integer function imbEtrailer(w)
C     ===============================

C--   Return 1 (0) if w has (not) a trailing empty table-set
C--
C--   Author: Michiel Botje h24@nikhef.nl   05-03-20

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      iaR    = iroot0                             !root address
      iaS    = int(w(IWlstS0+iaR)) + iaR          !IA trailing table-set
      NTabs  = int(w(NObjec0+iaS))                !# tables trailing set

      if(NTabs.ne.0) then
        imbEtrailer = 0
      else
        imbEtrailer = 1
      endif

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_wtable(double* w, int* imi, int* ima, int n);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_wtable FC_FUNC(imb_wtable,IMB_WTABLE)
CXXHFW    int fimb_wtable(double*, int*, int*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_wtable(double* w, int* imi, int* ima, int n)
CXXWRP    {
CXXWRP     int ia = fimb_wtable(w, imi, ima, &n);
CXXWRP     return iaFtoC(ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     ========================================
      integer function imb_WTable(w,imi,ima,n)
C     ========================================

C--   Book new table
C--
C--   w           (in): workspace
C--   imi,ima     (in): index limits
C--   n           (in): number of dimensions [1,mdim0]
C--   imb_WTable (out): IA address of the new table

C--   Author: Michiel Botje h24@nikhef.nl   17-11-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*), imi(*), ima(*), ival(2)

C--   Check if workspace
      if(int(w(iCword0+iroot0)).ne.iWsVersion0) then
        stop 'MBUTIL:IMB_WTABLE: W is not a workspace'
      endif
C--   Check input and get table size
      if(n.lt.1 .or. n.gt.mdim0) then
        stop 'MBUTIL:IMB_WTABLE: Ndim not in range [1,25]'
      endif
      nw = 1
      do i = 1,n
        if(imi(i).gt.ima(i)) stop 'MBUTIL:IMB_WTABLE: imin > imax'
        nw = nw*(ima(i)-imi(i)+1)
      enddo
C--   Addresses
      iaR    = iroot0                             !root address
      iaS    = int(w(IWlstS0+iaR)) + iaR          !IA current table-set
      iaL    = int(w(IWlstT0+iaR)) + iaR          !IA current table
      iaT    = int(w(INwUse0+iaR)) + iaR          !IA new table
      NBskip = iaL-iaT                            !Bskip table
      NSskip = iaS-iaT                            !Bskip table set
C--   Check workspace size
      NSsize = int(w(INwUse0+iaS))                !table-set size
      NHskip = int(w(IHskip0+iaS))                !header+tag size
      NWused = int(w(INwUse0+iaR))                !words used
      NTsize = nw + 3*n + 2 + NHskip              !table size
      NWneed = NWused + NTsize + 1                !words needed
      Nspace = int(w(INwMax0+iaR))                !total size
C--   Run out-of-space
      if(NWneed.gt.Nspace) call smbWsEmsg(w,NWneed,'MBUTIL:IMB_WTABLE')
C--   Initialise
      do i = iaT,NWneed
        w(i) = 0.D0
      enddo
C--   Local addresses of first word of metadata items
      itnd1          = NHskip
      itka1          = NHskip+1
      itmi1          = NHskip+n+2
      itma1          = NHskip+n+n+2
      ittb1          = NHskip+n+n+n+2
C--   Fill metadata
      w(iaT+itnd1)   = dble(n)
      call smb_dkmat(imi,ima,w(iaT+itka1),n,ittb1,ittb2)
      if(ittb2.ne.NTsize-1) stop
     +                     'MBUTIL:IMB_WTABLE: problem with table size'
      call smb_Vitod(imi,w(iaT+itmi1),n)
      call smb_Vitod(ima,w(iaT+itma1),n)
C--   Table fingerprint
      ival(1)        = n
      jh             = imb_ihash(0,ival,1)
      jh             = imb_jhash(jh,w(iaT+itka1),n+1)
      jh             = imb_ihash(jh,imi,n)
      jh             = imb_ihash(jh,ima,n)
      ihash          = imb_jhash(0,w(iaT+itnd1),n+n+n+2)
      if(ihash.ne.jh) stop
     +               'MBUTIL:IMB_WTABLE: problem with fingerprint'
      NObjec = int(w(NObjec0+iaS)) + 1            !# tables
C--   Fill Header
      w(ICword0+iaT) = dble(iCWTable0)            !control word
      w(IwAddr0+iaT) = dble(NWused)               !IW
      w(NFTabl0+iaT) = 0.D0                       !Fskip table
      w(NBTabl0+iaT) = dble(NBskip)               !Bskip table
      w(NFTset0+iaT) = 0.D0                       !Fskip tset
      w(NBTset0+iaT) = dble(NSskip)               !Bskip tset
      w(Ifprnt0+iaT) = dble(ihash)                !fingerprint
      w(NObjec0+iaT) = 0.D0                       !number of objects
      w(IObjec0+iaT) = dble(NObjec)               !Object number
      w(INwUse0+iaT) = dble(NTsize)               !Table size
      w(ItMeta0+iaT) = dble(itnd1)                !IT Metadata
      w(ItImin0+iaT) = dble(itmi1)                !IT IMIN
      w(ItImax0+iaT) = dble(itma1)                !IT IMAX
      w(ItBody0+iaT) = dble(ittb1)                !IT begin body
      w(ItBend0+iaT) = dble(ittb2)                !IT end body
C--   Update Wspace header
      w(IWlstT0+iaR) = dble(NWused)               !IW this table
      w(INwUse0+iaR) = dble(NWused+NTsize)        !Words used
      w(NFTabl0+iaR) = dble(NHskip+NHskip)        !Fskip table
C--   Update table-set fingerprint
      jhash   = int(w(Ifprnt0+iaS))               !old fingerprint
      ival(1) = ihash                             !table fingerprint
      jhash   = imb_ihash(jhash,ival,1)           !new fingerprint
C--   Update table set header
      w(NFTabl0+iaS) = dble(NHskip)               !Fskip table
      w(Ifprnt0+iaS) = dble(jhash)                !fingerprint
      w(NObjec0+iaS) = dble(NObjec)               !Number of objects
      w(INwUse0+iaS) = dble(NSsize+NTsize)        !Table-set size
      w(ISlstT0+iaS) = dble(NSsize)               !IS this table
C--   Return address
      imb_WTable = iaT
C--   Done for first table
      if(NBskip.eq.0) return
C--   Update Header previous table
      w(NFTabl0+iaL) = iaT - iaL                  !Fskip table

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_wclone(double *obj, double *w2);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_wclone FC_FUNC(imb_wclone,IMB_WCLONE)
CXXHFW    int fimb_wclone(double*, int*, double*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_wclone(double *obj, double *w2)
CXXWRP    {
CXXWRP     int ja1    = int(*(obj+1));
CXXWRP     double *w1 = obj-ja1;
CXXWRP     int ia1    = iaCtoF(ja1);
CXXWRP     int ia     = fimb_wclone(w1, &ia1, w2);
CXXWRP     return iaFtoC(ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     ========================================
      integer function imb_WClone(w1, ia1, w2)
C     ========================================

C--   Clone a table-set or table

C--   Author: Michiel Botje h24@nikhef.nl   09-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w1(*), w2(*)

C--   Check input
      if(int(w1(iCword0+iroot0)).ne.iWsVersion0) stop
     +                        'MBUTIL:IMB_WCLONE: W1 is not a workspace'
      if(ia1.le.0 .or. ia1.gt.int(w1(INwUse0+iroot0))) stop
     +                        'MBUTIL:IMB_WCLONE: IA1 out of range'
      if(int(w2(iCword0+iroot0)).ne.iWsVersion0) stop
     +                        'MBUTIL:IMB_WCLONE: W2 is not a workspace'
      if(int(w1(iCword0+ia1)).ne.iCWTableSet0 .and.
     +   int(w1(iCword0+ia1)).ne.iCWTable0) stop
     +  'MBUTIL:IMB_WCLONE: object to clone is not a table-set or table'

C--   Check workspace size
      iaR    = iroot0                             !workspace base
      iaS    = int(w1(IWlstS0+iaR)) + iaR         !IA current table-set
      NHskip = int(w1(IHskip0+iaS))               !header+tag size
      NCsize = int(w1(INwUse0+ia1))               !object size
      NWused = int(w2(INwUse0+iaR))               !words used
      Nspace = int(w2(INwMax0+iaR))               !total size
      if(imbEtrailer(w2).eq.1) then
        NWneed = NWused + NCsize - NHskip + 1     !words needed
      else
        NWneed = NWused + NCsize + 1              !words needed
      endif
C--   Run out-of-space
      if(NWneed.gt.Nspace) call smbWsEmsg(w2,NWneed,'MBUTIL:IMB_WCLONE')

      if(int(w1(ICword0+ia1)).eq.iCWTableSet0) then
C--     Clone table set
C--     New table set in w2
        iaS   = imb_NewSet(w2)
C--     Clone w1 tables to w2
        iaT1  = ia1 + int(w1(ia1+2))
        iaT2  = imbTClone(w1,iaT1,w2)
        iskip = int(w1(iaT1+3))
        do while(iskip.ne.0)
          iaT1  = iaT1 + iskip
          iaT2  = imbTClone(w1,iaT1,w2)
          iskip = int(w1(iaT1+3))
        enddo
        imb_WClone = iaS
      else
C--     Clone table
        imb_WClone = imbTClone(w1,ia1,w2)
      endif

      return
      end

C     =======================================
      integer function imbTClone(w1, ia1, w2)
C     =======================================

C--   Clone table

C--   Author: Michiel Botje h24@nikhef.nl   02-03-20

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w1(*), w2(*), ival(2)

C--   Workspace size
      iaR    = iroot0                             !workspace base
      NCsize = int(w1(INwUse0+ia1))               !object size
      NWused = int(w2(INwUse0+iaR))               !words used

C--   Clone table
      iaS    = int(w2(IWlstS0+iaR)) + iaR         !IA this table-set
      iaL    = int(w2(IWlstT0+iaR)) + iaR         !IA current table
      iaT    = int(w2(INwUse0+iaR)) + iaR         !IA new     table
      NBskip = iaL-iaT                            !Bskip table
      NSskip = iaS-iaT                            !Bskip table set
C--   Clone
      call smb_vcopy(w1(ia1),w2(iaT),NCsize)
      NSsize = int(w2(INwUse0+iaS))               !table-set size
      NHskip = int(w2(IHskip0+iaS))               !header+tag size
      NObjec = int(w2(NObjec0+iaS)) + 1           !update #tables
C--   Update table header
      w2(IwAddr0+iaT) = dble(NWused)              !IW
      w2(NFTabl0+iaT) = 0.D0                      !Fskip table
      w2(NBTabl0+iaT) = dble(NBskip)              !Bskip table
      w2(NFTset0+iaT) = 0.D0                      !Fskip tset
      w2(NBTset0+iaT) = dble(NSskip)              !Bskip tset
      w2(IObjec0+iaT) = dble(NObjec)              !Object number
C--   Update Wspace Header
      w2(IWlstT0+iaR) = dble(NWused)              !IW this table
      w2(INwUse0+iaR) = dble(NWused+NCsize)       !Words used
C--   Update table-set fingerprint
      jhash   = int(w2(Ifprnt0+iaS))              !old fingerprint
      ival(1) = int(w2(IFprnt0+iaT))              !table fingerprint
      jhash   = imb_ihash(jhash,ival,1)           !new fingerprint
C--   Update table-set header
      w2(NFTabl0+iaS) = dble(NHskip)              !Fskip table
      w2(Ifprnt0+iaS) = dble(jhash)               !fingerprint
      w2(NObjec0+iaS) = dble(NObjec)              !Number of objects
      w2(INwUse0+iaS) = dble(NSsize+NCsize)       !Table-set size
      w2(ISlstT0+iaS) = dble(NSsize)              !IS this table
C--   Return address
      imbTClone = iaT
C--   Update header previous table
      if(NBskip.eq.0) return
      w2(NFTabl0+iaL) = iaT - iaL                 !Fskip table

      return
      end

C-----------------------------------------------------------------------
CXXHDR    void smb_tbcopy(double *tab1, double *tab2, int itag);
C-----------------------------------------------------------------------
CXXHFW  #define fsmb_tbcopy FC_FUNC(smb_tbcopy,SMB_TBCOPY)
CXXHFW    void fsmb_tbcopy(double*, int*, double*, int*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    void smb_tbcopy(double *tab1, double *tab2, int itag)
CXXWRP    {
CXXWRP     int ja1    = int(*(tab1+1));
CXXWRP     int ja2    = int(*(tab2+1));
CXXWRP     double *w1 = tab1-ja1;
CXXWRP     double *w2 = tab2-ja2;
CXXWRP     int ia1    = iaCtoF(ja1);
CXXWRP     int ia2    = iaCtoF(ja2);
CXXWRP     fsmb_tbcopy(w1, &ia1, w2, &ia2, &itag);
CXXWRP    }
C-----------------------------------------------------------------------

C     =========================================
      subroutine smb_TbCopy(w1,ia1,w2,ia2,itag)
C     =========================================

C--   Copy table content and also yes(no) tags for itag = 1(0)

C--   Author: Michiel Botje h24@nikhef.nl   09-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w1(*), w2(*)

C--   Check input
      if(int(w1(iCword0+iroot0)).ne.iWsVersion0) stop
     +                   'MBUTIL:SMB_TBCOPY: W1 is not a workspace'
      if(int(w2(iCword0+iroot0)).ne.iWsVersion0) stop
     +                   'MBUTIL:SMB_TBCOPY: W2 is not a workspace'
      if(ia1.le.0 .or. ia1.gt.int(w1(INwUse0+iroot0))) stop
     +                   'MBUTIL:SMB_TBCOPY: IA1 out of range'
      if(ia2.le.0 .or. ia2.gt.int(w2(INwUse0+iroot0))) stop
     +                   'MBUTIL:SMB_TBCOPY: IA2 out of range'
      if(int(w1(iCword0+ia1)).ne.iCWTable0) stop
     +                   'MBUTIL:SMB_TBCOPY: source object is not table'
      if(int(w2(iCword0+ia2)).ne.iCWTable0) stop
     +                   'MBUTIL:SMB_TBCOPY: target object is not table'
      if(itag.ne.0 .and. itag.ne.1) stop
     +                   'MBUTIL:SMB_TBCOPY: itag should be 0 or 1'
C--   Check target = source
      ifw1 = int(w1(IFprnt0+iroot0))
      ifw2 = int(w2(IFprnt0+iroot0))
      if(ifw1.eq.ifw2 .and. ia1.eq.ia2) return
C--   Compare fingerprints
      ift1 = int(w1(IFprnt0+ia1))
      ift2 = int(w2(IFprnt0+ia2))
      if(ift1.ne.ift2) stop
     +  'MBUTIL:SMB_TBCOPY: source and target fingerprints do not match'
C--   Copy table body
      it1 = int(w1(ItBody0+ia1))
      it2 = int(w1(ItBend0+ia1))
      do it = it1,it2
        w2(ia2+it) = w1(ia1+it)
      enddo
      if(itag.eq.0) return
C--   Copy tag field
      is1 = ia1 + int(w1(NBTset0+ia1))
      is2 = ia2 + int(w2(NBTset0+ia2))
      nh1 = int(w1(INhead0+is1))
      nh2 = int(w2(INhead0+is2))
      if(nh1.ne.nh2) stop 'MBUTIL:SMB_TBCOPY: different header size'
      nt1 = int(w1(INtags0+is1))
      nt2 = int(w2(INtags0+is2))
      if(nt1.ne.nt2) stop 'MBUTIL:SMB_TBCOPY: different tag-field size'
      ja1 = ia1+nh1
      ja2 = ia2+nh2
      do j = 0,nt1
        w2(ja2+j) = w1(ja1+j)
      enddo

      return
      end

C-----------------------------------------------------------------------
CXXHDR    void smb_wswipe(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fsmb_wswipe FC_FUNC(smb_wswipe,SMB_WSWIPE)
CXXHFW    void fsmb_wswipe(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    void smb_wswipe(double *obj)
CXXWRP    {
CXXWRP     int ja     = int(*(obj+1));
CXXWRP     double *w  = obj-ja;
CXXWRP     int ia     = iaCtoF(ja);
CXXWRP     fsmb_wswipe(w, &ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     ===========================
      subroutine smb_WsWipe(w,ia)
C     ===========================

C--   Wipe workspace starting at object ia

C--   Author: Michiel Botje h24@nikhef.nl   29-01-21

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*), ival(2)

      iaR = iroot0                                         !root address
      iaN = int(w(INwUse0+iaR))                          !last word used

C--   Check input
      if(int(w(iCword0+iaR)).ne.iWsVersion0) stop
     +                        'MBUTIL:SMB_WSWIPE: W is not a workspace'
      if(ia.le.0 .or. ia.gt.iaN) stop
     +                        'MBUTIL:SMB_WSWIPE: IA out of range'

      iaS    = int(w(NFTset0+iaR)) + iaR          !first tbset
      iaT    = int(w(NFTabl0+iaR)) + iaR          !first table
      nwmax  = int(w(INwMax0+iaR))                !total size
      nhskip = int(w(IHskip0+iaS))                !hskip
      nhead  = int(w(INhead0+iaS))                !header size
      ntags  = int(w(INtags0+iaS))                !tag size

C-(1) if ia = root, first set or first table then restore WSINIT status
      if(ia.eq.iaR .or. ia.eq.iaS .or. ia.eq.iaT) then
        ival(1)        = nhead
        ival(2)        = ntags
        ihash          = 0
        ihash          = imb_ihash(ihash,ival,2)  !tbset initial fprint
        nsize          = nhskip + nhskip          !nused after wipe
C--     Update root header
        w(NFTabl0+iaR) = 0.D0                     !Fskip table
        w(NFTset0+iaR) = dble(nhskip)             !Fskip tbset
        w(NObjec0+iaR) = 1.D0                     !Number of objects
        w(IWlstS0+iaR) = dble(nhskip)             !IW last tbset in w
        w(IWlstT0+iaR) = dble(nhskip+nhskip)      !IW last table in w
        w(INwUse0+iaR) = dble(nsize)              !Words used
C--     Update 1st table-set header
        w(NFTabl0+iaS) = 0.D0                     !Fskip table
        w(NBTabl0+iaS) = 0.D0                     !Bskip table
        w(NFTset0+iaS) = 0.D0                     !Fskip tset
        w(NBTset0+iaS) = 0.D0                     !Bskip tset
        w(IFprnt0+iaS) = dble(ihash)              !Fingerprint
        w(NObjec0+iaS) = 0.D0                     !number of tables
        w(INwUse0+iaS) = dble(nhskip)             !Oject  size
        w(ISlstT0+iaS) = dble(nhskip)             !IS first table in ts
C--     Wipe
        call smb_Vfill(w(nsize+1),nwmax-nsize,0.D0)
        return
      endif

C-(2) Wipe starting with table-set
      if(int(w(ICword0+ia)).eq.iCWTableSet0)    then
        iaS    = ia                             !IA current  tbset
        iaL    = int(w(NBTset0+iaS)) + iaS      !IA previous tbset
C--     Update header of tables in previous table-set
        nskip  = int(w(NFTabl0+iaL))            !Dist to table1 in iaL
        iaT    = iaL
        do while(nskip.ne.0)                    !Loop over tables in iaL
          iaT            = iaT + nskip          !IA of table
          w(NFTset0+iaT) = 0.D0                 !Set SFskip to zero
          nskip          = int(w(NFTabl0+iaT))  !Distance to next table
        enddo
C--     Update header of previous table-set
        w(NFTset0+iaL)   = 0.D0                 !Set SFskip to zero
C--     Update root header
        ntsets = int(w(IObjec0+iaS)) - 1        !Nb of sets after wipe
        nwsize = iaS - 1                        !Nused after wipe
        w(NObjec0+iaR) = dble(ntsets)           !Number of objects
        w(IWlstS0+iaR) = dble(iaL-iaR)          !IW last tbset in w
        w(IWlstT0+iaR) = dble(iaT-iaR)          !IW last table in w
        w(INwUse0+iaR) = dble(nwsize)           !Words used
C--     Wipe
        call smb_Vfill(w(nwsize+1),nwmax-nwsize,0.D0)
        return
      endif

C-(3) Wipe starting with first table in set
      if(int(w(ICword0+ia)).eq.iCWTable0 .and.
     +   int(w(IObjec0+ia)).eq.1)               then
        iaS    = int(w(NBTset0+ia)) + ia        !IA current tbset
C--     Update current table-set header
        ihash = 0
        ihash = imb_ihash(ihash,nhead,1)
        ihash = imb_ihash(ihash,ntags,1)
        w(NFTabl0+iaS) = 0.D0                   !Fskip table
        w(NFTset0+iaS) = 0.D0                   !Fskip tset
        w(IFprnt0+iaS) = dble(ihash)            !Fingerprint
        w(NObjec0+iaS) = 0.D0                   !number of tables
        w(INwUse0+iaS) = dble(nhskip)           !Oject  size
        w(ISlstT0+iaS) = dble(nhskip)           !IS first table in ts
C--     Update root header
        ntsets = int(w(IObjec0+iaS))            !Nb of sets after wipe
        nwsize = ia - 1                         !Nused after wipe
        iaT    = int(w(NBTabl0+iaS)) + iaS      !IA last table in w
        w(NObjec0+iaR) = dble(ntsets)           !Number of objects
        w(IWlstS0+iaR) = dble(iaS-iaR)          !IW last tbset in w
        w(IWlstT0+iaR) = dble(iaS+nhskip-iaR)   !IW last table in w
        w(INwUse0+iaR) = dble(nwsize)           !Words used
C--     Wipe
        call smb_Vfill(w(nwsize+1),nwmax-nwsize,0.D0)
        return
      endif

C-(4) Wipe starting with table (not first table in set)
      if(int(w(ICword0+ia)).eq.iCWTable0)       then
        iaT    = ia                             !IA current  table
        iaS    = int(w(NBTset0+iaT)) + iaT      !IA current tbset
C--     Update header of previous tables in this set
        nskip            = int(w(NBTabl0+iaT))  !Dist to previous table
        iaL              = iaT + nskip          !IA previous table
        w(NFTabl0+iaL)   = 0.D0                 !TFskip previous table
        iaL              = iaT
        do while(nskip.ne.0)                    !Loop over tables in iaS
          iaL            = iaL + nskip          !IA of table
          w(NFTset0+iaL) = 0.D0                 !Set SFskip to zero
          nskip          = int(w(NBTabl0+iaL))  !Dist to previous table
        enddo
C--     Update header of current table-set
        ihash = 0
        ihash = imb_ihash(ihash,nhead,1)
        ihash = imb_ihash(ihash,ntags,1)
        nskip = int(w(NFTabl0+iaS))             !Dist first table in iaS
        iaT   = iaS
        ntabs = 0
        do while(nskip.ne.0)                    !Loop over tables in iaS
          ntabs   = ntabs + 1                   !Number of tables
          iaT     = iaT + nskip                 !IA of table
          ifp     = int(w(IFprnt0+iaT))         !Fingerprint of table
          ihash   = imb_ihash(ihash,ifp,1)      !Update fprint of iaS
          nskip   = int(w(NFTabl0+iaT))         !Dist to next table
        enddo
        w(NFTset0+iaS) = 0.D0                   !Set SFskip to zero
        w(IFprnt0+iaS) = dble(ihash)            !Fingerprint of iaS
        w(NObjec0+iaS) = dble(ntabs)            !Number of tables in iaS
        w(INwUse0+iaS) = dble(ia-iaS)           !Size of iaS
        w(ISlstT0+iaS) = dble(iaT-iaS)          !IS last table
C--     Update root header
        ntsets = int(w(IObjec0+iaS))            !Nb of sets after wipe
        nwsize = ia - 1                         !Nused after wipe
        w(NObjec0+iaR) = dble(ntsets)           !Number of objects
        w(IWlstS0+iaR) = dble(iaS-iaR)          !IW last tbset in w
        w(IWlstT0+iaR) = dble(iaT-iaR)          !IW last table in w
        w(INwUse0+iaR) = dble(nwsize)           !Words used
C--     Wipe
        call smb_Vfill(w(nwsize+1),nwmax-nwsize,0.D0)
        return
      endif

C-(5) No valid input address
      stop 'MBUTIL:SMB_WSWIPE: IA not root, table-set or table address'

      end

C-----------------------------------------------------------------------
CXXHDR    void smb_tsdump(string fname, int key, double *tset, int &ierr);
C-----------------------------------------------------------------------
CXXHFW  #define fsmb_tsdumpcpp FC_FUNC(smb_tsdumpcpp,SMB_TSDUMPCPP)
CXXHFW    void fsmb_tsdumpcpp(char*, int*, int*, double*, int*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    void smb_tsdump(string fname, int key, double *tset, int &ierr)
CXXWRP    {
CXXWRP     int ls = fname.size();
CXXWRP     char *cfname = new char[ls];
CXXWRP     strcpy(cfname,fname.c_str());
CXXWRP     int ja     = int(*(tset+1));
CXXWRP     double *w  = tset-ja;
CXXWRP     int ia     = iaCtoF(ja);
CXXWRP     fsmb_tsdumpcpp(cfname, &ls, &key, w, &ia, &ierr);
CXXWRP    }
C-----------------------------------------------------------------------

C     ================================================
      subroutine smb_TsDumpCPP(fname,ls,key,w,ia,ierr)
C     ================================================

      implicit double precision (a-h,o-z)

      character*(100) fname
      dimension w(*)

      if(ls.gt.100) stop
     +             'MBUTIL:SMB_TSDUMP: input file name > 100 characters'

      call smb_TsDump(fname,key,w,ia,ierr)

      return
      end

C     ==========================================
      subroutine smb_TsDump(fname,key,w,ia,ierr)
C     ==========================================

C--   Author: Michiel Botje h24@nikhef.nl   04-03-20

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      character*(*) fname
      dimension w(*)

C--   Check input
      if(int(w(ICword0+iroot0)).ne.iWsVersion0) stop
     +            'MBUTIL:SMB_TSDUMP: W is not a workspace'
      if(ia.le.0 .or. ia.gt.int(w(INwUse0+iroot0))) stop
     +            'MBUTIL:SMB_TSDUMP: IA out of range'
      if(int(w(ICword0+ia)).ne.iCWTableSet0) stop
     +            'MBUTIL:SMB_TSDUMP: object to dump is not a table-set'
      if(int(w(NObjec0+ia)).eq.0) stop
     +            'MBUTIL:SMB_TSDUMP: cannot dump empty table-set'

C--   Open file
      lun = imb_nextL(0)
      if(lun.eq.0) stop
     +            'MBUTIL:SMB_TSDUMP: no logical unit number available'
      open(unit=lun,file=fname,form='unformatted',
     +     status='unknown',err=500)
      ierr = 0
      ivers  = int(w(ICword0+iroot0))
      nhead  = int(w(INhead0+ia))
      ntags  = int(w(INtags0+ia))
      ifprnt = int(w(IFprnt0+ia))
      nwords = int(w(INwUse0+ia))
      ntabs  = int(w(NObjec0+ia))
      ifskip = int(w(NFTabl0+ia))
      i1     = ia + nhead
      i2     = ia + nwords-1
      nw     = i2-i1+1
C--   Write header info
      write(lun,err=500) key,ivers,nhead,ntags,ifprnt,ntabs,nw
C--   Write the table-set but without the reader
      write(lun,err=500) (w(i),i=i1,i2)
      close(lun)
C--   Debug print
*      write(6,'(/'' SMB_TSDUMP: key   = '',I10)') key
*      write(6,'( ''             ivers = '',I10)') ivers
*      write(6,'( ''             nhead = '',I10)') nhead
*      write(6,'( ''             ntags = '',I10)') ntags
*      write(6,'( ''             fprnt = '',I10)') ifprnt
*      write(6,'( ''             nwtab = '',I10)') nw
*      write(6,'( ''             ntabs = '',I10)') ntabs
*      write(6,'( ''             ia1   = '',I10)') i1
*      write(6,'( ''             ia2   = '',I10)') i2

      return

  500 continue
C--   Open or write error
      ierr = -1
      return

      end

C-----------------------------------------------------------------------
CXXHDR    int imb_tsread(string fname, int key, double *w, int &ierr);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_tsreadcpp FC_FUNC(imb_tsreadcpp,IMB_TSREADCPP)
CXXHFW    int fimb_tsreadcpp(char*, int*, int*, double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_tsread(string fname, int key, double *w, int &ierr)
CXXWRP    {
CXXWRP     int ls = fname.size();
CXXWRP     char *cfname = new char[ls];
CXXWRP     strcpy(cfname,fname.c_str());
CXXWRP     int ia = fimb_tsreadcpp(cfname, &ls, &key, w, &ierr);
CXXWRP     return iaFtoC(ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     ===================================================
      integer function imb_TsReadCPP(fname,ls,key,w,ierr)
C     ===================================================

      implicit double precision (a-h,o-z)

      character*(100) fname
      dimension w(*)

      if(ls.gt.100) stop
     +             'MBUTIL:IMB_TSREAD: input file name > 100 characters'

      imb_TsReadCPP = imb_TsRead(fname,key,w,ierr)

      return
      end

C     =============================================
      integer function imb_TsRead(fname,key,w,ierr)
C     =============================================

C--   Author: Michiel Botje h24@nikhef.nl   04-03-20

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      character*(*) fname
      dimension w(*)

C--   Init
      ierr = 0
      imb_TsRead = 0
C--   Check input
      if(int(w(ICword0+iroot0)).ne.iWsVersion0) stop
     +             'MBUTIL:IMB_TSREAD: W is not a workspace'
C--   Open file
      lun = imb_nextL(0)
      if(lun.eq.0) stop
     +             'MBUTIL:IMB_TSREAD: no logical unit number available'
      open(unit=lun,file=fname,form='unformatted',status='old',err=500)
C--   Read header info
      read(lun,err=500,end=500) keyr,ivers,nhead,ntags,ifprnt,ntabs,nw
      iaR    = iroot0                             !root address
      iaL    = int(w(IWlstS0+iaR)) + iaR          !IA current table-set
C--   Check key,ivers,nhead,ntags
      if(key.ne.0 .and. key.ne.keyr)       then
        ierr = -2
        return
      elseif(int(w(ICword0+iaR)).ne.ivers) then
        ierr = -2
        return
      elseif(int(w(INhead0+iaL)).ne.nhead) then
        ierr = -2
        return
      elseif(int(w(INtags0+iaL)).ne.ntags) then
        ierr = -2
        return
      endif
C--   Check workspace size
      NHskip = nhead + ntags
      NWused = int(w(INwUse0+iaR))                !words used
      Nspace = int(w(INwMax0+iaR))                !total size
      if( imbEtrailer(w) .eq. 1 ) then
        NWneed = NWused + nw + 1                  !words needed
      else
        NWneed = NWused + NHskip + nw + 1         !words needed
      endif
C--   Run out-of-space
      if(NWneed.gt.Nspace) call smbWsEmsg(w,NWneed,'MBUTIL:IMB_TSREAD')
C--   New table-set in w
      iaS    = imb_NewSet(w)
      NWused = int(w(INwUse0+iaR))                !words used
C--   Read table-set without header
      i1     = iaS + nhead
      i2     = i1  + nw-1
      read(lun,err=500,end=500) (w(i),i=i1,i2)
C--   Set distance to root in all table headers
      nfskip = NHskip
      iaT = iaS + nfskip
      do while(nfskip.ne.0)
        w(IwAddr0+iaT) = dble(iaT-iaR)
        nfskip         = int(w(NFTabl0+iaT))
        iaT            = iaT + nfskip
      enddo
C--   Update Wspace Header
      w(IWlstS0+iaR) = dble(iaS-iaR)              !IW last table-set
      w(IWlstT0+iaR) = dble(iaT-iaR)              !IW last table
      w(INwUse0+iaR) = dble(NWused+nw)            !Words used
      w(NFTabl0+iaR) = dble(NHskip+NHskip)        !Fskip table
C--   Update Table-set Header
      w(NFTabl0+iaS) = dble(NHskip)               !Fskip table
      w(Ifprnt0+iaS) = dble(ifprnt)               !fingerprint
      w(NObjec0+iaS) = dble(ntabs)                !Number of objects
      w(INwUse0+iaS) = dble(NHskip+nw)            !Table-set size
      w(ISlstT0+iaS) = dble(iaT-iaS)              !IS last table
C--   Return table set address
      imb_TsRead = iaS
C--   Close file
      close(lun)

      return

  500 continue
C--   Open or read error
      ierr = -1
      return

      end


C-----------------------------------------------------------------------
CXXHDR    void smb_wsmark(int &mws, int &mset, int &mtab );
C-----------------------------------------------------------------------
CXXHFW  #define fsmb_wsmark FC_FUNC(smb_wsmark,SMB_WSMARK)
CXXHFW    void fsmb_wsmark(int*, int*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    void smb_wsmark(int &mws, int &mset, int &mtab)
CXXWRP    {
CXXWRP     fsmb_wsmark(&mws, &mset, &mtab);
CXXWRP    }
C-----------------------------------------------------------------------

C     ======================================
      subroutine smb_WsMark(mws, mset, mtab)
C     ======================================

C--   Return current markers of root, table-set and table

C--   Author: Michiel Botje h24@nikhef.nl   30-01-21

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      mws  = iWsVersion0
      mset = iCWTableSet0
      mtab = iCWTable0

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_hdsize();
C-----------------------------------------------------------------------
CXXHFW  #define fimb_hdsize FC_FUNC(imb_hdsize,IMB_HDSIZE)
CXXHFW    int fimb_hdsize();
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_hdsize()
CXXWRP    {
CXXWRP     return fimb_hdsize();
CXXWRP    }
C-----------------------------------------------------------------------

C     =============================
      integer function imb_HdSize()
C     =============================

C--   Return header size

C--   Author: Michiel Botje h24@nikhef.nl   02-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      imb_HdSize = nwHeader0

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_tbsize(int *imi, int *ima, int ndim);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_tbsize FC_FUNC(imb_tbsize,IMB_TBSIZE)
CXXHFW    int fimb_tbsize(int*, int*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_tbsize(int *imi, int *ima, int ndim)
CXXWRP    {
CXXWRP     return fimb_tbsize(imi, ima, &ndim);
CXXWRP    }
C-----------------------------------------------------------------------

C     =========================================
      integer function imb_TbSize(imi,ima,ndim)
C     =========================================

C--   Table size (body + metadata)
C--
C--   imi, ima  (in): index limits
C--   ndim      (in): number of dimensions

C--   Author: Michiel Botje h24@nikhef.nl   02-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension imi(*), ima(*)

      if(ndim.lt.1 .or. ndim.gt.mdim0) stop
     +                      'MBUTIL:IMB_TBSIZE: ndim out of range'
      nw = 1
      do i = 1,ndim
        if(imi(i).gt.ima(i)) stop
     +                      'MBUTIL:IMB_TBSIZE: imin > imax encountered'
        nw = nw*(ima(i)-imi(i)+1)
      enddo

      imb_TbSize = nw + 3*ndim + 2

      return
      end

C=======================================================================
C==   Pointer functions  ===============================================
C=======================================================================

C     =========================================
      subroutine smbGetMeta(w,ia,nd,kk,imi,ima)
C     =========================================

C--   Extract metadata from a table
C--
C--   w            (in): workspace
C--   ia           (in): table address
C--   nd          (out): number of dimensions
C--   kk(nd+2)    (out): fingerprint + pointer coefficients
C--   imi,ima(nd) (out): index limits

C--   Author: Michiel Botje h24@nikhef.nl   27-11-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*), kk(*), imi(*), ima(*)

      mm     = int(w(ItMeta0+ia))+ia
      nd     = int(w(mm))
      mi     = mm+nd+1
      ma     = mi+nd
      kk(1)  = int(w(Ifprnt0+ia))
      kk(2)  = int(w(mm+1))
      do i = 1,nd
        kk(i+2) = int(w(mm+1+i))
        imi(i)  = int(w(mi+i))
        ima(i)  = int(w(ma+i))
      enddo

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_tpoint(double *table, int* index, int n);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_tpoint FC_FUNC(imb_tpoint,IMB_TPOINT)
CXXHFW    int fimb_tpoint(double*, int*, int*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_tpoint(double *table, int *index, int n)
CXXWRP    {
CXXWRP     int ja    = int(*(table+1));
CXXWRP     double *w = table-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     int iadr  = fimb_tpoint(w, &ia, index, &n);
CXXWRP     return iaFtoC(iadr);
CXXWRP    }
C-----------------------------------------------------------------------

C     =========================================
      integer function imb_TPoint(w,ia,index,n)
C     =========================================

C--   Pointer function
C--
C--   w, ia     (in): Table ia in workspace w
C--   index     (in): Array with ndim index values
C--   n         (in): Dimension of index as set in the calling routine

C--   Author: Michiel Botje h24@nikhef.nl   02-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*), index(*)
      save nd, kk, imi, ima
      dimension kk(mdim0+2), imi(mdim0), ima(mdim0)

C--   Check input
      if(n.le.0) stop 'MBUTIL:IMB_TPOINT: n <= 0'
      if(int(w(iroot0)).ne.iWsVersion0) stop
     +                'MBUTIL:IMB_TPOINT: W is not a workspace'
      if(ia.le.0 .or. ia.gt.int(w(INwUse0+iroot0))) stop
     +                'MBUTIL:IMB_TPOINT: IA out of range'
      if(int(w(ia)).ne.iCWTable0) stop
     +                'MBUTIL:IMB_TPOINT: IA is not a table address'
C--   Fingerprint
      ifp = int(w(Ifprnt0+ia))
C--   Load metadata, if needed
      if(kk(1).ne.ifp) call smbGetMeta(w,ia,nd,kk,imi,ima)
      if(n.lt.nd) stop        'MBUTIL:IMB_TPOINT: n < ndim of table'
C--   Check index range and build pointer
      ipoint = kk(2) + ia
      do i = 1,nd
        if(index(i).lt.imi(i) .or. index(i).gt.ima(i)) then
          write(6,
     +        '(''MBUTIL:IMB_TPOINT: index '',I3,'' out of range'')') i
          stop
        endif
        ipoint = ipoint + kk(i+2)*index(i)
      enddo
C--   Check pointer
      ibot = int(w(ItBody0+ia))+ia
      ieot = int(w(ItBend0+ia))+ia
      if(ipoint.lt.ibot .or. ipoint.gt.ieot)
     +   stop 'MBUTIL:IMB_TPOINT: calculated pointer outside table body'

      imb_TPoint = ipoint

      return
      end

C=======================================================================
C==   Access to information ============================================
C=======================================================================

C-----------------------------------------------------------------------
CXXHDR
CXXHDR    int imb_IsaWorkspace(double *obj);
C-----------------------------------------------------------------------
CXXHFW
CXXHFW  #define fimb_isaworkspace FC_FUNC(imb_isaworkspace,IMB_ISAWORKSPACE)
CXXHFW    int fimb_isaworkspace(double*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_IsaWorkspace(double *obj)
CXXWRP    {
CXXWRP     int ia    = int(*(obj+1));
CXXWRP     double *w = obj-ia;
CXXWRP     return fimb_isaworkspace(w);
CXXWRP    }
C-----------------------------------------------------------------------

C     ====================================
      integer function imb_IsaWorkspace(w)
C     ====================================

C--   Return 1 (0) if w is (not) a workspace

C--   Author: Michiel Botje h24@nikhef.nl   03-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      if(int(w(iCword0+iroot0)).eq.iWsVersion0) then
        imb_IsaWorkspace = 1
      else
        imb_IsaWorkspace = 0
      endif

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_SizeOfW(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_sizeofw FC_FUNC(imb_sizeofw,IMB_SIZEOFW)
CXXHFW    int fimb_sizeofw(double*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_SizeOfW(double *obj)
CXXWRP    {
CXXWRP     int ia    = int(*(obj+1));
CXXWRP     double *w = obj-ia;
CXXWRP     return fimb_sizeofw(w);
CXXWRP    }
C-----------------------------------------------------------------------

C     ===============================
      integer function imb_SizeOfW(w)
C     ===============================

C--   Total size of w

C--   Author: Michiel Botje h24@nikhef.nl   03-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      imb_SizeOfW = int(w(iNwMax0+iroot0))

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_WordsUsed(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_wordsused FC_FUNC(imb_wordsused,IMB_WORDSUSED)
CXXHFW    int fimb_wordsused(double*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_WordsUsed(double *obj)
CXXWRP    {
CXXWRP     int ia    = int(*(obj+1));
CXXWRP     double *w = obj-ia;
CXXWRP     return fimb_wordsused(w);
CXXWRP    }
C-----------------------------------------------------------------------

C     =================================
      integer function imb_WordsUsed(w)
C     =================================

C--   Words used

C--   Author: Michiel Botje h24@nikhef.nl   03-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      imb_WordsUsed = int(w(INwUse0+iroot0))

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_Nheader(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_nheader FC_FUNC(imb_nheader,IMB_NHEADER)
CXXHFW    int fimb_nheader(double*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_Nheader(double *obj)
CXXWRP    {
CXXWRP     int ia    = int(*(obj+1));
CXXWRP     double *w = obj-ia;
CXXWRP     return fimb_nheader(w);
CXXWRP    }
C-----------------------------------------------------------------------

C     ===============================
      integer function imb_Nheader(w)
C     ===============================

C--   Header size

C--   Author: Michiel Botje h24@nikhef.nl   03-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      iaS         = int(w(IWlstS0+iroot0))+iroot0
      imb_Nheader = int(w(INhead0+iaS))

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_Ntags(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_ntags FC_FUNC(imb_ntags,IMB_NTAGS)
CXXHFW    int fimb_ntags(double*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_Ntags(double *obj)
CXXWRP    {
CXXWRP     int ia    = int(*(obj+1));
CXXWRP     double *w = obj-ia;
CXXWRP     return fimb_ntags(w);
CXXWRP    }
C-----------------------------------------------------------------------

C     =============================
      integer function imb_Ntags(w)
C     =============================

C--   Tag field size

C--   Author: Michiel Botje h24@nikhef.nl   03-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      iaS       = int(w(IWlstS0+iroot0))+iroot0
      imb_Ntags = int(w(INtags0+iaS))

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_HeadSkip(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_headskip FC_FUNC(imb_headskip,IMB_HEADSKIP)
CXXHFW    int fimb_headskip(double*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_HeadSkip(double *obj)
CXXWRP    {
CXXWRP     int ia    = int(*(obj+1));
CXXWRP     double *w = obj-ia;
CXXWRP     return fimb_headskip(w);
CXXWRP    }
C-----------------------------------------------------------------------

C     ================================
      integer function imb_HeadSkip(w)
C     ================================

C--   Header + tag field size

C--   Author: Michiel Botje h24@nikhef.nl   03-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      iaS          = int(w(IWlstS0+iroot0))+iroot0
      imb_HeadSkip = int(w(IHskip0+iaS))

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_IaRoot();
C-----------------------------------------------------------------------
CXXHFW  #define fimb_iaroot FC_FUNC(imb_iaroot,IMB_IAROOT)
CXXHFW    int fimb_iaroot();
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_IaRoot()
CXXWRP    {
CXXWRP     int ja    = fimb_iaroot();
CXXWRP     return iaFtoC(ja);
CXXWRP    }
C-----------------------------------------------------------------------

C     =============================
      integer function imb_IaRoot()
C     =============================

C--   Root address

C--   Author: Michiel Botje h24@nikhef.nl   02-03-20

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      imb_IaRoot = iroot0

      return
      end


C-----------------------------------------------------------------------
CXXHDR    int imb_IaDrain(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_iadrain FC_FUNC(imb_iadrain,IMB_IADRAIN)
CXXHFW    int fimb_iadrain(double*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_IaDrain(double *obj)
CXXWRP    {
CXXWRP     int ia    = int(*(obj+1));
CXXWRP     double *w = obj-ia;
CXXWRP     int ja    = fimb_iadrain(w);
CXXWRP     return iaFtoC(ja);
CXXWRP    }
C-----------------------------------------------------------------------

C     ===============================
      integer function imb_IaDrain(w)
C     ===============================

C--   Drain-word address

C--   Author: Michiel Botje h24@nikhef.nl   03-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      dum         = w(1)                         !avoid compiler warning
      imb_IaDrain = IDrain0 + iroot0

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_IaNull(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_ianull FC_FUNC(imb_ianull,IMB_IANULL)
CXXHFW    int fimb_ianull(double*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_IaNull(double *obj)
CXXWRP    {
CXXWRP     int ia    = int(*(obj+1));
CXXWRP     double *w = obj-ia;
CXXWRP     int ja    = fimb_ianull(w);
CXXWRP     return iaFtoC(ja);
CXXWRP    }
C-----------------------------------------------------------------------

C     ==============================
      integer function imb_IaNull(w)
C     ==============================

C--   Null-word address

C--   Author: Michiel Botje h24@nikhef.nl   03-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      dum        = w(1)                          !avoid compiler warning
      imb_IaNull = IZnull0+iroot0

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_ObjectType(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_objecttype FC_FUNC(imb_objecttype,IMB_OBJECTTYPE)
CXXHFW    int fimb_objecttype(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_ObjectType(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     return fimb_objecttype(w, &ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     =====================================
      integer function imb_ObjectType(w,ia)
C     =====================================

C--   Return object type

C--   Author: Michiel Botje h24@nikhef.nl   03-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      imb_ObjectType = 0

      if(int(w(ia)).eq.iWsVersion0)      then
        imb_ObjectType = 1
      elseif(int(w(ia)).eq.iCWTableSet0) then
        imb_ObjectType = 2
      elseif(int(w(ia)).eq.iCWTable0)    then
        imb_ObjectType = 3
      endif

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_ObjectSize(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_objectsize FC_FUNC(imb_objectsize,IMB_OBJECTSIZE)
CXXHFW    int fimb_objectsize(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_ObjectSize(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     return fimb_objectsize(w, &ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     =====================================
      integer function imb_ObjectSize(w,ia)
C     =====================================

C--   Return object size

C--   Author: Michiel Botje h24@nikhef.nl   03-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      imb_ObjectSize = int(w(INwUse0+ia))

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_Nobjects(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_nobjects FC_FUNC(imb_nobjects,IMB_NOBJECTS)
CXXHFW    int fimb_nobjects(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_Nobjects(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     return fimb_nobjects(w, &ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     ===================================
      integer function imb_Nobjects(w,ia)
C     ===================================

C--   Return object size

C--   Author: Michiel Botje h24@nikhef.nl   03-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      imb_Nobjects = int(w(NObjec0+ia))

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_ObjectNumber(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_objectnumber FC_FUNC(imb_objectnumber,IMB_OBJECTNUMBER)
CXXHFW    int fimb_objectnumber(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_ObjectNumber(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     return fimb_objectnumber(w, &ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     =======================================
      integer function imb_ObjectNumber(w,ia)
C     =======================================

C--   Return object size

C--   Author: Michiel Botje h24@nikhef.nl   03-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      imb_ObjectNumber = int(w(IObjec0+ia))

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_FingerPrint(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_fingerprint FC_FUNC(imb_fingerprint,IMB_FINGERPRINT)
CXXHFW    int fimb_fingerprint(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_FingerPrint(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     return fimb_fingerprint(w, &ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     ======================================
      integer function imb_FingerPrint(w,ia)
C     ======================================

C--   Return object size

C--   Author: Michiel Botje h24@nikhef.nl   04-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      imb_FingerPrint = int(w(IFprnt0+ia))

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_IaFirstTag(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_iafirsttag FC_FUNC(imb_iafirsttag,IMB_IAFIRSTTAG)
CXXHFW    int fimb_iafirsttag(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_IaFirstTag(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     int ift   = fimb_iafirsttag(w, &ia);
CXXWRP     return iaFtoC(ift);
CXXWRP    }
C-----------------------------------------------------------------------

C     =====================================
      integer function imb_IaFirstTag(w,ia)
C     =====================================

C--   Null-word address

C--   Author: Michiel Botje h24@nikhef.nl   03-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      dum            = w(1)                      !avoid compiler warning
      imb_IaFirstTag = ia + nwHeader0

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_TableDim(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_tabledim FC_FUNC(imb_tabledim,IMB_TABLEDIM)
CXXHFW    int fimb_tabledim(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_TableDim(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     return fimb_tabledim(w, &ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     ===================================
      integer function imb_TableDim(w,ia)
C     ===================================

C--   Number of dimensions of table ia

C--   Author: Michiel Botje h24@nikhef.nl   04-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      ja           = int(w(itMeta0+ia))+ia
      imb_TableDim = int(w(ja))

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_IaKARRAY(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_iakarray FC_FUNC(imb_iakarray,IMB_IAKARRAY)
CXXHFW    int fimb_iakarray(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_IaKARRAY(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     int iak   = fimb_iakarray(w, &ia);
CXXWRP     return iaFtoC(iak);
CXXWRP    }
C-----------------------------------------------------------------------

C     ===================================
      integer function imb_IaKARRAY(w,ia)
C     ===================================

C--   First word of KARRAY

C--   Author: Michiel Botje h24@nikhef.nl   04-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      imb_IaKARRAY = int(w(itMeta0+ia))+ia+1

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_IaIMIN(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_iaimin FC_FUNC(imb_iaimin ,IMB_IAIMIN)
CXXHFW    int fimb_iaimin(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_IaIMIN(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     int iak   = fimb_iaimin(w, &ia);
CXXWRP     return iaFtoC(iak);
CXXWRP    }
C-----------------------------------------------------------------------

C     ===================================
      integer function imb_IaIMIN(w,ia)
C     ===================================

C--   First word of IMIN

C--   Author: Michiel Botje h24@nikhef.nl   04-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      imb_IaIMIN = int(w(itImin0+ia))+ia

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_IaIMAX(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_iaimax FC_FUNC(imb_iaimax ,IMB_IAIMAX)
CXXHFW    int fimb_iaimax(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_IaIMAX(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     int iak   = fimb_iaimax(w, &ia);
CXXWRP     return iaFtoC(iak);
CXXWRP    }
C-----------------------------------------------------------------------

C     =================================
      integer function imb_IaIMAX(w,ia)
C     =================================

C--   First word of IMAX

C--   Author: Michiel Botje h24@nikhef.nl   04-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      imb_IaIMAX = int(w(itImax0+ia))+ia

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_BeginTbody(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_begintbody FC_FUNC(imb_begintbody ,IMB_BEGINTBODY)
CXXHFW    int fimb_begintbody(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_BeginTbody(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     int iak   = fimb_begintbody(w, &ia);
CXXWRP     return iaFtoC(iak);
CXXWRP    }
C-----------------------------------------------------------------------

C     =====================================
      integer function imb_BeginTbody(w,ia)
C     =====================================

C--   First word of table body

C--   Author: Michiel Botje h24@nikhef.nl   04-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      imb_BeginTbody = int(w(itBody0+ia))+ia

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_EndTbody(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_endtbody FC_FUNC(imb_endtbody ,IMB_ENDTBODY)
CXXHFW    int fimb_endtbody(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_EndTbody(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     int iak   = fimb_endtbody(w, &ia);
CXXWRP     return iaFtoC(iak);
CXXWRP    }
C-----------------------------------------------------------------------

C     =====================================
      integer function imb_EndTbody(w,ia)
C     =====================================

C--   Last word of table body

C--   Author: Michiel Botje h24@nikhef.nl   04-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      imb_EndTbody = int(w(itBend0+ia))+ia

      return
      end

C=======================================================================
C==   Navigation =======================================================
C=======================================================================

C-----------------------------------------------------------------------
CXXHDR    int imb_tfskip(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_tfskip FC_FUNC(imb_tfskip ,IMB_TFSKIP)
CXXHFW    int fimb_tfskip(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_tfskip(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     return fimb_tfskip(w, &ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     =================================
      integer function imb_TFskip(w,ia)
C     =================================

C--   Distance (signed) to next table marker

C--   Author: Michiel Botje h24@nikhef.nl   04-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

C--   Check input
      if(int(w(iroot0)).ne.iWsVersion0) stop
     +                        'MBUTIL:IMB_TFSKIP: W is not a workspace'
      if(ia.le.0 .or. ia.gt.int(w(INwUse0+iroot0))) stop
     +                        'MBUTIL:IMB_TFSKIP: IA out of range'
C--   Go
      mark = int(w(ia))
      if(mark.eq.iWsVersion0  .or.
     +   mark.eq.iCWTableSet0 .or. mark.eq.iCWTable0) then
        imb_TFskip = int(w(NFTabl0+ia))
      else
        imb_TFskip = 0
      endif

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_tbskip(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_tbskip FC_FUNC(imb_tbskip ,IMB_TBSKIP)
CXXHFW    int fimb_tbskip(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_tbskip(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     return fimb_tbskip(w, &ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     =================================
      integer function imb_TBskip(w,ia)
C     =================================

C--   Distance (signed) to previous table marker

C--   Author: Michiel Botje h24@nikhef.nl   04-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

C--   Check input
      if(int(w(iroot0)).ne.iWsVersion0) stop
     +                  'MBUTIL:IMB_TBSKIP: W is not a workspace'
      if(ia.le.0) stop  'MBUTIL:IMB_TBSKIP: IA out of range'

C--   Special case ia > last word used
      nwused = int(w(INwUse0+iroot0))
      if(ia.gt.nwused) then
        iaLset = int(w(IWlstS0+iroot0)) + iroot0
        ntabs  = int(w(NObjec0+iaLset))
        if(ntabs.eq.0) then
          imb_TBskip = 0                          !no table in last tset
        else
          iaLtab     = int(w(IWlstT0+iroot0)) + iroot0
          imb_TBskip = iaLtab - ia
        endif
        return
      endif

C--   Go for ia in range
      mark = int(w(ia))
      if(mark.eq.iWsVersion0  .or.
     +   mark.eq.iCWTableSet0 .or. mark.eq.iCWTable0) then
        imb_TBskip = int(w(NBTabl0+ia))
      else
        imb_TBskip = 0
      endif

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_sfskip(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_sfskip FC_FUNC(imb_sfskip ,IMB_SFSKIP)
CXXHFW    int fimb_sfskip(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_sfskip(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     return fimb_sfskip(w, &ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     =================================
      integer function imb_SFskip(w,ia)
C     =================================

C--   Distance (signed) to next table-set marker

C--   Author: Michiel Botje h24@nikhef.nl   04-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

C--   Check input
      if(int(w(iroot0)).ne.iWsVersion0) stop
     +                        'MBUTIL:IMB_SFSKIP: W is not a workspace'
      if(ia.le.0 .or. ia.gt.int(w(INwUse0+iroot0))) stop
     +                        'MBUTIL:IMB_SFSKIP: IA out of range'
C--   Go
      mark = int(w(ia))
      if(mark.eq.iWsVersion0  .or.
     +   mark.eq.iCWTableSet0 .or. mark.eq.iCWTable0) then
        imb_SFskip = int(w(NFTset0+ia))
      else
        imb_SFskip = 0
      endif

      return
      end

C-----------------------------------------------------------------------
CXXHDR    int imb_sbskip(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fimb_sbskip FC_FUNC(imb_sbskip ,IMB_SBSKIP)
CXXHFW    int fimb_sbskip(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    int imb_sbskip(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     return fimb_sbskip(w, &ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     =================================
      integer function imb_SBskip(w,ia)
C     =================================

C--   Distance (signed) to previous table-set marker

C--   Author: Michiel Botje h24@nikhef.nl   04-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

C--   Check input
      if(int(w(iroot0)).ne.iWsVersion0) stop
     +                  'MBUTIL:IMB_SBSKIP: W is not a workspace'
      if(ia.le.0) stop  'MBUTIL:IMB_SBSKIP: IA out of range'

C--   Special case ia > last word used
      nwused = int(w(INwUse0+iroot0))
      if(ia.gt.nwused) then
        iaLset = int(w(IWlstS0+iroot0)) + iroot0
        imb_SBskip = iaLset - ia
        return
      endif

C--   Go for ia in range
      mark = int(w(ia))
      if(mark.eq.iWsVersion0  .or.
     +   mark.eq.iCWTableSet0 .or. mark.eq.iCWTable0) then
        imb_SBskip = int(w(NBTset0+ia))
      else
        imb_SBskip = 0
      endif

      return
      end

C=======================================================================
C==  Verbose dumps  ====================================================
C=======================================================================

C-----------------------------------------------------------------------
CXXHDR    void smb_wstree(double *w);
C-----------------------------------------------------------------------
CXXHFW  #define fsmbwstree FC_FUNC(smbwstree ,SMBWSTREE)
CXXHFW    int fsmbwstree(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    void smb_wstree(double *w)
CXXWRP    {
CXXWRP     int iroot    = 0;
CXXWRP     fsmbwstree(w,&iroot);
CXXWRP    }
C-----------------------------------------------------------------------

C     ========================
      subroutine smb_WStree(w)
C     ========================

C--   Print workspace tree

C--   Author: Michiel Botje h24@nikhef.nl   12-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

      call smbWStree(w,1)

      return
      end

C     ==============================
      subroutine  smbWStree(w,iroot)
C     ==============================

C--   The iroot argumant takes care of the address printouts
C--   Fortran iroot = 1 --> print address as is
C--   C++     iroot = 0 --> substract 1 from all addresses

C--   Author: Michiel Botje h24@nikhef.nl   12-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

C--   Check input
      if(int(w(iroot0)).ne.iWsVersion0) stop
     +                        'MBUTIL:SMB_WSTREE: W is not a workspace'
      if(iroot.ne.0 .and. iroot.ne.1) stop
     +                        'MBUTIL:SMB_WSTREE: iroot must be 0 or 1'

      ia = 1                                 !address of workspace
      call smbwprint(w,ia,iroot)             !print workspace
      id = int(w(NFTset0+ia))                !distance to 1st table-set
      do while(id.ne.0)                      !loop over table-sets
        ia = ia+id                           !address of table-set
        call smbsprint(w,ia,iroot)           !print table-set
        jd = int(w(NFTabl0+ia))              !distance to first table
        do while(jd.ne.0)                    !loop over tables
          ia = ia+jd                         !address of table
          call smbtprint(w,ia,iroot)         !print table
          jd = int(w(NFTabl0+ia))            !distance to next table
        enddo                                !end loop over tables
        id = int(w(NFTset0+ia))              !distance to next table-set
      enddo                                  !end loop over table-sets

      return
      end

C     ================================
      subroutine smbwprint(w,ia,iroot)
C     ================================

C--   The iroot argumant takes care of the address printouts
C--   Fortran iroot = 1 --> print address as is
C--   C++     iroot = 0 --> substract 1 from all addresses

C--   Author: Michiel Botje h24@nikhef.nl   12-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)
      character*15 number, hcode
      character*80 text

C--   Check input address
      if(int(w(ia)).ne.iWsVersion0) stop
     +                'MBUTIL:SMBWPRINT: IA is not a workspace address'

      iadr  = ia-iroot0+iroot
      nwds  = int(w(INwUse0+ia))
      ifpt  = int(w(IFprnt0+ia))
      nobj  = int(w(NObjec0+ia))
      call smb_itoch(nobj,number,leng)
      call smb_hcode(ifpt,hcode)
      call smb_cfill(' ',text)
      text = 'workspace with '//number(1:leng)//' table-sets'
      ltxt = imb_lastc(text)

      write(6,'(/1X,''ADDRESS'',4X,''SIZE'',8X,''FINGERPRINT'',
     +           4X,''OBJECT'')')
      write(6,'(2I8,4X,A15,4X,A)') iadr, nwds, hcode, text(1:ltxt)

      return
      end

C     ================================
      subroutine smbsprint(w,ia,iroot)
C     ================================

C--   The iroot argumant takes care of the address printouts
C--   Fortran iroot = 1 --> print address as is
C--   C++     iroot = 0 --> substract 1 from all addresses

C--   Author: Michiel Botje h24@nikhef.nl   12-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)
      character*15 number, hcode
      character*80 text

C--   Check input address
      if(int(w(ia)).ne.iCWTableSet0) stop
     +                'MBUTIL:SMBSPRINT: IA is not a table-set address'

      iadr  = ia-iroot0+iroot
      nwds  = int(w(INwUse0+ia))
      ifpt  = int(w(IFprnt0+ia))
      nobj  = int(w(NObjec0+ia))
      call smb_itoch(nobj,number,leng)
      call smb_hcode(ifpt,hcode)
      call smb_cfill(' ',text)
      text = '--- table-set with '//number(1:leng)//' tables'
      ltxt = imb_lastc(text)

      write(6,'(2I8,4X,A15,4X,A)') iadr, nwds, hcode, text(1:ltxt)

      return
      end

C     ================================
      subroutine smbtprint(w,ia,iroot)
C     ================================

C--   The iroot argumant takes care of the address printouts
C--   Fortran iroot = 1 --> print address as is
C--   C++     iroot = 0 --> substract 1 from all addresses

C--   Author: Michiel Botje h24@nikhef.nl   12-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)
      character*15 number, hcode
      character*80 text

C--   Check input address
      if(int(w(ia)).ne.iCWTable0) stop
     +                    'MBUTIL:SMBTPRINT: IA is not a table address'

      iadr  = ia-iroot0+iroot
      nwds  = int(w(INwUse0+ia))
      ifpt  = int(w(IFprnt0+ia))
      idim  = int(w(ItMeta0+ia))+ia
      ndim  = int(w(idim))
      call smb_itoch(ndim,number,leng)
      call smb_hcode(ifpt,hcode)
      call smb_cfill(' ',text)
      text = '------- table with '//number(1:leng)//' dimensions'
      ltxt = imb_lastc(text)

      write(6,'(2I8,4X,A15,4X,A)') iadr, nwds, hcode, text(1:ltxt)

      return
      end

C-----------------------------------------------------------------------
CXXHDR    void smb_wshead(double *obj);
C-----------------------------------------------------------------------
CXXHFW  #define fsmb_wshead FC_FUNC(smb_wshead ,SMB_WSHEAD)
CXXHFW    int fsmb_wshead(double*, int*);
C-----------------------------------------------------------------------
CXXWRP  //--------------------------------------------------------------
CXXWRP    void smb_wshead(double *obj)
CXXWRP    {
CXXWRP     int ja    = int(*(obj+1));
CXXWRP     double *w = obj-ja;
CXXWRP     int ia    = iaCtoF(ja);
CXXWRP     fsmb_wshead(w,&ia);
CXXWRP    }
C-----------------------------------------------------------------------

C     ===========================
      subroutine smb_WShead(w,ia)
C     ===========================

C--   Print header of workspace, table-set or table

C--   Author: Michiel Botje h24@nikhef.nl   12-12-19

      implicit double precision (a-h,o-z)

      include 'wspace0.inc'

      dimension w(*)

C--   Check input
      if(int(w(iroot0)).ne.iWsVersion0) stop
     +                        'MBUTIL:SMB_WSHEAD: W is not a workspace'
      if(ia.le.0 .or. ia.gt.int(w(INwUse0+iroot0))) stop
     +                        'MBUTIL:SMB_WSHEAD: IA out of range'

      if(int(w(ia)).eq.iWsVersion0) then
         write(6,'(/'' Workspace Header'')')
         write(6,'( '' 0 Cword    '',I15  )') int(w(ICword0+ia))
         write(6,'( '' 1 IW       '',I15  )') int(w(IwAddr0+ia))
         write(6,'( '' 2 TFskip   '',I15  )') int(w(NFTabl0+ia))
         write(6,'( '' 3 TBskip   '',I15  )') int(w(NBTabl0+ia))
         write(6,'( '' 4 SFskip   '',I15  )') int(w(NFTset0+ia))
         write(6,'( '' 5 SBskip   '',I15  )') int(w(NBTset0+ia))
         write(6,'( '' 6 Fprint   '',I15  )') int(w(IFprnt0+ia))
         write(6,'( '' 7 Nobj     '',I15  )') int(w(NObjec0+ia))
         write(6,'( '' 8 Iobj     '',I15  )') int(w(IObjec0+ia))
         write(6,'( '' 9 NWused   '',I15  )') int(w(INwUse0+ia))
         write(6,'( ''10 IW Lset  '',I15  )') int(w(IWlstS0+ia))
         write(6,'( ''11 IW Ltab  '',I15  )') int(w(IWlstT0+ia))
         write(6,'( ''12 NWtotal  '',I15  )') int(w(iNwMax0+ia))
         write(6,'( ''13 Drain    '',E15.5)')     w(IDrain0+ia)
         write(6,'( ''14 Null     '',E15.5)')     w(IZnull0+ia)
      elseif(int(w(ia)).eq.iCWTableSet0) then
         write(6,'(/'' Table-set Header'')')
         write(6,'( '' 0 Cword    '',I15  )') int(w(ICword0+ia))
         write(6,'( '' 1 IW       '',I15  )') int(w(IwAddr0+ia))
         write(6,'( '' 2 TFskip   '',I15  )') int(w(NFTabl0+ia))
         write(6,'( '' 3 TBskip   '',I15  )') int(w(NBTabl0+ia))
         write(6,'( '' 4 SFskip   '',I15  )') int(w(NFTset0+ia))
         write(6,'( '' 5 SBskip   '',I15  )') int(w(NBTset0+ia))
         write(6,'( '' 6 Fprint   '',I15  )') int(w(IFprnt0+ia))
         write(6,'( '' 7 Nobj     '',I15  )') int(w(NObjec0+ia))
         write(6,'( '' 8 Iobj     '',I15  )') int(w(IObjec0+ia))
         write(6,'( '' 9 NWused   '',I15  )') int(w(INwUse0+ia))
         write(6,'( ''10 Hsize    '',I15  )') int(w(INhead0+ia))
         write(6,'( ''11 TagSize  '',I15  )') int(w(INtags0+ia))
         write(6,'( ''12 Hskip    '',I15  )') int(w(IHskip0+ia))
         write(6,'( ''13 IS Ltab  '',I15  )') int(w(ISlstT0+ia))
      elseif(int(w(ia)).eq.iCWTable0) then
         write(6,'(/'' Table Header'')')
         write(6,'( '' 0 Cword    '',I15  )') int(w(ICword0+ia))
         write(6,'( '' 1 IW       '',I15  )') int(w(IwAddr0+ia))
         write(6,'( '' 2 TFskip   '',I15  )') int(w(NFTabl0+ia))
         write(6,'( '' 3 TBskip   '',I15  )') int(w(NBTabl0+ia))
         write(6,'( '' 4 SFskip   '',I15  )') int(w(NFTset0+ia))
         write(6,'( '' 5 SBskip   '',I15  )') int(w(NBTset0+ia))
         write(6,'( '' 6 Fprint   '',I15  )') int(w(IFprnt0+ia))
         write(6,'( '' 7 Nobj     '',I15  )') int(w(NObjec0+ia))
         write(6,'( '' 8 Iobj     '',I15  )') int(w(IObjec0+ia))
         write(6,'( '' 9 NWused   '',I15  )') int(w(INwUse0+ia))
         write(6,'( ''10 IT Meta  '',I15  )') int(w(ItMeta0+ia))
         write(6,'( ''11 IT IMIN  '',I15  )') int(w(ItImin0+ia))
         write(6,'( ''12 IT IMAX  '',I15  )') int(w(ItImax0+ia))
         write(6,'( ''13 IT Bbody '',I15  )') int(w(ItBody0+ia))
         write(6,'( ''14 IT Ebody '',I15  )') int(w(ItBend0+ia))
      else
         stop
     +  'MBUTIL:SMB_WSHEAD: IA is not a workspace, table-set or table'
      endif

      return
      end

